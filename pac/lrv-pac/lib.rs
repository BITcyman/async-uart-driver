#![doc = "Peripheral access API for LRV-16550 microcontrollers (generated using svd2rust v0.27.2 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.27.2/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also `modify`'ed."]
    pub trait Readable: RegisterSpec {
        #[doc = " Result from a call to `read` and argument to `modify`."]
        type Reader: From<R<Self>> + core::ops::Deref<Target = R<Self>>;
    }
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Writer type argument to `write`, et al."]
        type Writer: From<W<Self>> + core::ops::DerefMut<Target = W<Self>>;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> REG::Reader {
            REG::Reader::from(R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            })
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut REG::Writer) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut REG::Writer::from(W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                }))
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&REG::Reader, &'w mut REG::Writer) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &REG::Reader::from(R {
                        bits,
                        _reg: marker::PhantomData,
                    }),
                    &mut REG::Writer::from(W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    }),
                )
                .bits,
            );
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub struct R<REG: RegisterSpec + ?Sized> {
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub struct W<REG: RegisterSpec + ?Sized> {
        #[doc = "Writable bits"]
        pub(crate) bits: REG::Ux,
        _reg: marker::PhantomData<REG>,
    }
    impl<REG: RegisterSpec> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Read datasheet or reference manual to find what values are allowed to pass."]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc(hidden)]
    pub struct FieldReaderRaw<U, T> {
        pub(crate) bits: U,
        _reg: marker::PhantomData<T>,
    }
    impl<U, FI> FieldReaderRaw<U, FI>
    where
        U: Copy,
    {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: U) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitReaderRaw<T> {
        pub(crate) bits: bool,
        _reg: marker::PhantomData<T>,
    }
    impl<FI> BitReaderRaw<FI> {
        #[doc = " Creates a new instance of the reader."]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(bits: bool) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<U, FI> = FieldReaderRaw<U, FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI> = BitReaderRaw<FI>;
    impl<U, FI> FieldReader<U, FI>
    where
        U: Copy,
    {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub fn bits(&self) -> U {
            self.bits
        }
    }
    impl<U, FI> PartialEq<FI> for FieldReader<U, FI>
    where
        U: PartialEq,
        FI: Copy,
        U: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&U::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc(hidden)]
    pub struct Safe;
    #[doc(hidden)]
    pub struct Unsafe;
    #[doc(hidden)]
    pub struct FieldWriterRaw<'a, U, REG, N, FI, Safety, const WI: u8, const O: u8>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(N, FI, Safety)>,
    }
    impl<'a, U, REG, N, FI, Safety, const WI: u8, const O: u8>
        FieldWriterRaw<'a, U, REG, N, FI, Safety, WI, O>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc(hidden)]
    pub struct BitWriterRaw<'a, U, REG, FI, M, const O: u8>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        bool: From<FI>,
    {
        pub(crate) w: &'a mut REG::Writer,
        _field: marker::PhantomData<(FI, M)>,
    }
    impl<'a, U, REG, FI, M, const O: u8> BitWriterRaw<'a, U, REG, FI, M, O>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        bool: From<FI>,
    {
        #[doc = " Creates a new instance of the writer"]
        #[allow(unused)]
        #[inline(always)]
        pub(crate) fn new(w: &'a mut REG::Writer) -> Self {
            Self {
                w,
                _field: marker::PhantomData,
            }
        }
    }
    #[doc = " Write field Proxy with unsafe `bits`"]
    pub type FieldWriter<'a, U, REG, N, FI, const WI: u8, const O: u8> =
        FieldWriterRaw<'a, U, REG, N, FI, Unsafe, WI, O>;
    #[doc = " Write field Proxy with safe `bits`"]
    pub type FieldWriterSafe<'a, U, REG, N, FI, const WI: u8, const O: u8> =
        FieldWriterRaw<'a, U, REG, N, FI, Safe, WI, O>;
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriter<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriterSafe<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        N: From<FI>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, U, REG, FI, const O: u8> = BitWriterRaw<'a, U, REG, FI, $mwv, O>;
            impl<'a, U, REG, FI, const OF: u8> $writer<'a, U, REG, FI, OF>
            where
                REG: Writable + RegisterSpec<Ux = U>,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
            }
        };
    }
    macro_rules! impl_bit_proxy {
        ($ writer : ident) => {
            impl<'a, U, REG, FI, const OF: u8> $writer<'a, U, REG, FI, OF>
            where
                REG: Writable + RegisterSpec<Ux = U>,
                U: RawReg,
                bool: From<FI>,
            {
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut REG::Writer {
                    self.w.bits &= !(U::one() << OF);
                    self.w.bits |= (U::from(value) & U::one()) << OF;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriter<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg + From<N>,
        N: From<FI>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: N) -> &'a mut REG::Writer {
            self.w.bits &= !(U::mask::<WI>() << OF);
            self.w.bits |= (U::from(value) & U::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            unsafe { self.bits(N::from(variant)) }
        }
    }
    impl<'a, U, REG, N, FI, const WI: u8, const OF: u8> FieldWriterSafe<'a, U, REG, N, FI, WI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg + From<N>,
        N: From<FI>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn bits(self, value: N) -> &'a mut REG::Writer {
            self.w.bits &= !(U::mask::<WI>() << OF);
            self.w.bits |= (U::from(value) & U::mask::<WI>()) << OF;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut REG::Writer {
            self.bits(N::from(variant))
        }
    }
    impl_bit_proxy!(BitWriter);
    impl_bit_proxy!(BitWriter1S);
    impl_bit_proxy!(BitWriter0C);
    impl_bit_proxy!(BitWriter1C);
    impl_bit_proxy!(BitWriter0S);
    impl_bit_proxy!(BitWriter1T);
    impl_bit_proxy!(BitWriter0T);
    impl<'a, U, REG, FI, const OF: u8> BitWriter<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1S<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0C<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1C<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0S<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter1T<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits |= U::one() << OF;
            self.w
        }
    }
    impl<'a, U, REG, FI, const OF: u8> BitWriter0T<'a, U, REG, FI, OF>
    where
        REG: Writable + RegisterSpec<Ux = U>,
        U: RawReg,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut REG::Writer {
            self.w.bits &= !(U::one() << OF);
            self.w
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
pub union Vector {
    pub _handler: unsafe extern "C" fn(),
    pub _reserved: usize,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[no_mangle]
pub static __EXTERNAL_INTERRUPTS: [Vector; 0] = [];
#[doc = "Universal Asynchronous Receiver Transmitter"]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x6000_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART0 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "Universal Asynchronous Receiver Transmitter"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x6000_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART1 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART1").finish()
    }
}
#[doc = "Universal Asynchronous Receiver Transmitter"]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x6000_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART2 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART2").finish()
    }
}
#[doc = "Universal Asynchronous Receiver Transmitter"]
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x6000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART3 {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART3").finish()
    }
}
#[doc = "Universal Asynchronous Receiver Transmitter"]
pub mod uart {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved_0_dll: [u8; 0x04],
        _reserved_1_dlh: [u8; 0x04],
        _reserved_2_fcr: [u8; 0x04],
        #[doc = "0x0c - UART Line Control Register"]
        pub lcr: LCR,
        #[doc = "0x10 - UART Modem Control Register"]
        pub mcr: MCR,
        #[doc = "0x14 - UART Line Status Register"]
        pub lsr: LSR,
        #[doc = "0x18 - UART Modem Status Register"]
        pub msr: MSR,
        #[doc = "0x1c - UART Scratch Register"]
        pub sch: SCH,
    }
    impl RegisterBlock {
        #[doc = "0x00 - UART Divisor Latch Low Register"]
        #[inline(always)]
        pub const fn dll(&self) -> &DLL {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
        #[doc = "0x00 - UART Transmit Holding Register"]
        #[inline(always)]
        pub const fn thr(&self) -> &THR {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
        #[doc = "0x00 - UART Receive Buffer Register"]
        #[inline(always)]
        pub const fn rbr(&self) -> &RBR {
            unsafe { &*(self as *const Self).cast::<u8>().add(0usize).cast() }
        }
        #[doc = "0x04 - UART Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ier(&self) -> &IER {
            unsafe { &*(self as *const Self).cast::<u8>().add(4usize).cast() }
        }
        #[doc = "0x04 - UART Divisor Latch High Register"]
        #[inline(always)]
        pub const fn dlh(&self) -> &DLH {
            unsafe { &*(self as *const Self).cast::<u8>().add(4usize).cast() }
        }
        #[doc = "0x08 - UART FIFO Control Register"]
        #[inline(always)]
        pub const fn fcr(&self) -> &FCR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
        #[doc = "0x08 - UART Interrupt Identity Register"]
        #[inline(always)]
        pub const fn iir(&self) -> &IIR {
            unsafe { &*(self as *const Self).cast::<u8>().add(8usize).cast() }
        }
    }
    #[doc = "rbr (r) register accessor: an alias for `Reg<RBR_SPEC>`"]
    pub type RBR = crate::Reg<rbr::RBR_SPEC>;
    #[doc = "UART Receive Buffer Register"]
    pub mod rbr {
        #[doc = "Register `rbr` reader"]
        pub struct R(crate::R<RBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<RBR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<RBR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `rbr` reader - "]
        pub type RBR_R = crate::FieldReader<u8, u8>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn rbr(&self) -> RBR_R {
                RBR_R::new((self.bits & 0xff) as u8)
            }
        }
        #[doc = "UART Receive Buffer Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rbr](index.html) module"]
        pub struct RBR_SPEC;
        impl crate::RegisterSpec for RBR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [rbr::R](R) reader structure"]
        impl crate::Readable for RBR_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets rbr to value 0"]
        impl crate::Resettable for RBR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "thr (w) register accessor: an alias for `Reg<THR_SPEC>`"]
    pub type THR = crate::Reg<thr::THR_SPEC>;
    #[doc = "UART Transmit Holding Register"]
    pub mod thr {
        #[doc = "Register `thr` writer"]
        pub struct W(crate::W<THR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<THR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<THR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<THR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `thr` writer - "]
        pub type THR_W<'a, const O: u8> = crate::FieldWriter<'a, u32, THR_SPEC, u8, u8, 8, O>;
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn thr(&mut self) -> THR_W<0> {
                THR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Transmit Holding Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [thr](index.html) module"]
        pub struct THR_SPEC;
        impl crate::RegisterSpec for THR_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [thr::W](W) writer structure"]
        impl crate::Writable for THR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets thr to value 0"]
        impl crate::Resettable for THR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "dll (rw) register accessor: an alias for `Reg<DLL_SPEC>`"]
    pub type DLL = crate::Reg<dll::DLL_SPEC>;
    #[doc = "UART Divisor Latch Low Register"]
    pub mod dll {
        #[doc = "Register `dll` reader"]
        pub struct R(crate::R<DLL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DLL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DLL_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DLL_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `dll` writer"]
        pub struct W(crate::W<DLL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DLL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DLL_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DLL_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dll` reader - "]
        pub type DLL_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `dll` writer - "]
        pub type DLL_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DLL_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn dll(&self) -> DLL_R {
                DLL_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn dll(&mut self) -> DLL_W<0> {
                DLL_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Divisor Latch Low Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dll](index.html) module"]
        pub struct DLL_SPEC;
        impl crate::RegisterSpec for DLL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [dll::R](R) reader structure"]
        impl crate::Readable for DLL_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [dll::W](W) writer structure"]
        impl crate::Writable for DLL_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets dll to value 0"]
        impl crate::Resettable for DLL_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "dlh (rw) register accessor: an alias for `Reg<DLH_SPEC>`"]
    pub type DLH = crate::Reg<dlh::DLH_SPEC>;
    #[doc = "UART Divisor Latch High Register"]
    pub mod dlh {
        #[doc = "Register `dlh` reader"]
        pub struct R(crate::R<DLH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DLH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<DLH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<DLH_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `dlh` writer"]
        pub struct W(crate::W<DLH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DLH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<DLH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<DLH_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dlh` reader - "]
        pub type DLH_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `dlh` writer - "]
        pub type DLH_W<'a, const O: u8> = crate::FieldWriter<'a, u32, DLH_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn dlh(&self) -> DLH_R {
                DLH_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn dlh(&mut self) -> DLH_W<0> {
                DLH_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Divisor Latch High Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dlh](index.html) module"]
        pub struct DLH_SPEC;
        impl crate::RegisterSpec for DLH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [dlh::R](R) reader structure"]
        impl crate::Readable for DLH_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [dlh::W](W) writer structure"]
        impl crate::Writable for DLH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets dlh to value 0"]
        impl crate::Resettable for DLH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "ier (rw) register accessor: an alias for `Reg<IER_SPEC>`"]
    pub type IER = crate::Reg<ier::IER_SPEC>;
    #[doc = "UART Interrupt Enable Register"]
    pub mod ier {
        #[doc = "Register `ier` reader"]
        pub struct R(crate::R<IER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IER_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IER_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `ier` writer"]
        pub struct W(crate::W<IER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<IER_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<IER_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `erbfi` reader - Enable Received Data Available Interrupt"]
        pub type ERBFI_R = crate::BitReader<ERBFI_A>;
        #[doc = "Enable Received Data Available Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ERBFI_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<ERBFI_A> for bool {
            #[inline(always)]
            fn from(variant: ERBFI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ERBFI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ERBFI_A {
                match self.bits {
                    false => ERBFI_A::DISABLE,
                    true => ERBFI_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ERBFI_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ERBFI_A::ENABLE
            }
        }
        #[doc = "Field `erbfi` writer - Enable Received Data Available Interrupt"]
        pub type ERBFI_W<'a, const O: u8> = crate::BitWriter<'a, u32, IER_SPEC, ERBFI_A, O>;
        impl<'a, const O: u8> ERBFI_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ERBFI_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ERBFI_A::ENABLE)
            }
        }
        #[doc = "Field `etbei` reader - Enable Transmit Holding Register Empty Interrupt"]
        pub type ETBEI_R = crate::BitReader<ETBEI_A>;
        #[doc = "Enable Transmit Holding Register Empty Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ETBEI_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<ETBEI_A> for bool {
            #[inline(always)]
            fn from(variant: ETBEI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ETBEI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ETBEI_A {
                match self.bits {
                    false => ETBEI_A::DISABLE,
                    true => ETBEI_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ETBEI_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ETBEI_A::ENABLE
            }
        }
        #[doc = "Field `etbei` writer - Enable Transmit Holding Register Empty Interrupt"]
        pub type ETBEI_W<'a, const O: u8> = crate::BitWriter<'a, u32, IER_SPEC, ETBEI_A, O>;
        impl<'a, const O: u8> ETBEI_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ETBEI_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ETBEI_A::ENABLE)
            }
        }
        #[doc = "Field `elsi` reader - Enable Receiver Line Status Interrupt"]
        pub type ELSI_R = crate::BitReader<ELSI_A>;
        #[doc = "Enable Receiver Line Status Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum ELSI_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<ELSI_A> for bool {
            #[inline(always)]
            fn from(variant: ELSI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl ELSI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ELSI_A {
                match self.bits {
                    false => ELSI_A::DISABLE,
                    true => ELSI_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ELSI_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ELSI_A::ENABLE
            }
        }
        #[doc = "Field `elsi` writer - Enable Receiver Line Status Interrupt"]
        pub type ELSI_W<'a, const O: u8> = crate::BitWriter<'a, u32, IER_SPEC, ELSI_A, O>;
        impl<'a, const O: u8> ELSI_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ELSI_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ELSI_A::ENABLE)
            }
        }
        #[doc = "Field `edssi` reader - Enable Modem Status Interrupt"]
        pub type EDSSI_R = crate::BitReader<EDSSI_A>;
        #[doc = "Enable Modem Status Interrupt\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum EDSSI_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "1: `1`"]
            ENABLE = 1,
        }
        impl From<EDSSI_A> for bool {
            #[inline(always)]
            fn from(variant: EDSSI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl EDSSI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EDSSI_A {
                match self.bits {
                    false => EDSSI_A::DISABLE,
                    true => EDSSI_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == EDSSI_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == EDSSI_A::ENABLE
            }
        }
        #[doc = "Field `edssi` writer - Enable Modem Status Interrupt"]
        pub type EDSSI_W<'a, const O: u8> = crate::BitWriter<'a, u32, IER_SPEC, EDSSI_A, O>;
        impl<'a, const O: u8> EDSSI_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(EDSSI_A::DISABLE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EDSSI_A::ENABLE)
            }
        }
        impl R {
            #[doc = "Bit 0 - Enable Received Data Available Interrupt"]
            #[inline(always)]
            pub fn erbfi(&self) -> ERBFI_R {
                ERBFI_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enable Transmit Holding Register Empty Interrupt"]
            #[inline(always)]
            pub fn etbei(&self) -> ETBEI_R {
                ETBEI_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable Receiver Line Status Interrupt"]
            #[inline(always)]
            pub fn elsi(&self) -> ELSI_R {
                ELSI_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Enable Modem Status Interrupt"]
            #[inline(always)]
            pub fn edssi(&self) -> EDSSI_R {
                EDSSI_R::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable Received Data Available Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn erbfi(&mut self) -> ERBFI_W<0> {
                ERBFI_W::new(self)
            }
            #[doc = "Bit 1 - Enable Transmit Holding Register Empty Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn etbei(&mut self) -> ETBEI_W<1> {
                ETBEI_W::new(self)
            }
            #[doc = "Bit 2 - Enable Receiver Line Status Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn elsi(&mut self) -> ELSI_W<2> {
                ELSI_W::new(self)
            }
            #[doc = "Bit 3 - Enable Modem Status Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn edssi(&mut self) -> EDSSI_W<3> {
                EDSSI_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ier](index.html) module"]
        pub struct IER_SPEC;
        impl crate::RegisterSpec for IER_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [ier::R](R) reader structure"]
        impl crate::Readable for IER_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [ier::W](W) writer structure"]
        impl crate::Writable for IER_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets ier to value 0"]
        impl crate::Resettable for IER_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "iir (r) register accessor: an alias for `Reg<IIR_SPEC>`"]
    pub type IIR = crate::Reg<iir::IIR_SPEC>;
    #[doc = "UART Interrupt Identity Register"]
    pub mod iir {
        #[doc = "Register `iir` reader"]
        pub struct R(crate::R<IIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<IIR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<IIR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Field `iid` reader - Interrupt ID"]
        pub type IID_R = crate::FieldReader<u8, IID_A>;
        #[doc = "Interrupt ID\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum IID_A {
            #[doc = "0: `0`"]
            MODEM_STATUS = 0,
            #[doc = "1: `1`"]
            NO_INTERRUPT_PENDING = 1,
            #[doc = "2: `10`"]
            THR_EMPTY = 2,
            #[doc = "4: `100`"]
            RECEIVED_DATA_AVAILABLE = 4,
            #[doc = "6: `110`"]
            RECEIVER_LINE_STATUS = 6,
            #[doc = "12: `1100`"]
            CHARACTER_TIMEOUT = 12,
        }
        impl From<IID_A> for u8 {
            #[inline(always)]
            fn from(variant: IID_A) -> Self {
                variant as _
            }
        }
        impl IID_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<IID_A> {
                match self.bits {
                    0 => Some(IID_A::MODEM_STATUS),
                    1 => Some(IID_A::NO_INTERRUPT_PENDING),
                    2 => Some(IID_A::THR_EMPTY),
                    4 => Some(IID_A::RECEIVED_DATA_AVAILABLE),
                    6 => Some(IID_A::RECEIVER_LINE_STATUS),
                    12 => Some(IID_A::CHARACTER_TIMEOUT),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `MODEM_STATUS`"]
            #[inline(always)]
            pub fn is_modem_status(&self) -> bool {
                *self == IID_A::MODEM_STATUS
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_PENDING`"]
            #[inline(always)]
            pub fn is_no_interrupt_pending(&self) -> bool {
                *self == IID_A::NO_INTERRUPT_PENDING
            }
            #[doc = "Checks if the value of the field is `THR_EMPTY`"]
            #[inline(always)]
            pub fn is_thr_empty(&self) -> bool {
                *self == IID_A::THR_EMPTY
            }
            #[doc = "Checks if the value of the field is `RECEIVED_DATA_AVAILABLE`"]
            #[inline(always)]
            pub fn is_received_data_available(&self) -> bool {
                *self == IID_A::RECEIVED_DATA_AVAILABLE
            }
            #[doc = "Checks if the value of the field is `RECEIVER_LINE_STATUS`"]
            #[inline(always)]
            pub fn is_receiver_line_status(&self) -> bool {
                *self == IID_A::RECEIVER_LINE_STATUS
            }
            #[doc = "Checks if the value of the field is `CHARACTER_TIMEOUT`"]
            #[inline(always)]
            pub fn is_character_timeout(&self) -> bool {
                *self == IID_A::CHARACTER_TIMEOUT
            }
        }
        #[doc = "Field `feflag` reader - FIFOs Enable Flag"]
        pub type FEFLAG_R = crate::FieldReader<u8, FEFLAG_A>;
        #[doc = "FIFOs Enable Flag\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum FEFLAG_A {
            #[doc = "0: `0`"]
            DISABLE = 0,
            #[doc = "3: `11`"]
            ENABLE = 3,
        }
        impl From<FEFLAG_A> for u8 {
            #[inline(always)]
            fn from(variant: FEFLAG_A) -> Self {
                variant as _
            }
        }
        impl FEFLAG_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<FEFLAG_A> {
                match self.bits {
                    0 => Some(FEFLAG_A::DISABLE),
                    3 => Some(FEFLAG_A::ENABLE),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == FEFLAG_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == FEFLAG_A::ENABLE
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Interrupt ID"]
            #[inline(always)]
            pub fn iid(&self) -> IID_R {
                IID_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 6:7 - FIFOs Enable Flag"]
            #[inline(always)]
            pub fn feflag(&self) -> FEFLAG_R {
                FEFLAG_R::new(((self.bits >> 6) & 3) as u8)
            }
        }
        #[doc = "UART Interrupt Identity Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iir](index.html) module"]
        pub struct IIR_SPEC;
        impl crate::RegisterSpec for IIR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [iir::R](R) reader structure"]
        impl crate::Readable for IIR_SPEC {
            type Reader = R;
        }
        #[doc = "`reset()` method sets iir to value 0"]
        impl crate::Resettable for IIR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "fcr (w) register accessor: an alias for `Reg<FCR_SPEC>`"]
    pub type FCR = crate::Reg<fcr::FCR_SPEC>;
    #[doc = "UART FIFO Control Register"]
    pub mod fcr {
        #[doc = "Register `fcr` writer"]
        pub struct W(crate::W<FCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<FCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<FCR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `fifoe` writer - "]
        pub type FIFOE_W<'a, const O: u8> = crate::BitWriter<'a, u32, FCR_SPEC, bool, O>;
        #[doc = "Field `rfifor` writer - "]
        pub type RFIFOR_W<'a, const O: u8> = crate::BitWriter<'a, u32, FCR_SPEC, bool, O>;
        #[doc = "Field `xfifor` writer - "]
        pub type XFIFOR_W<'a, const O: u8> = crate::BitWriter<'a, u32, FCR_SPEC, bool, O>;
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DMAM_AW {
            #[doc = "0: `0`"]
            MODE_0 = 0,
            #[doc = "1: `1`"]
            MODE_1 = 1,
        }
        impl From<DMAM_AW> for bool {
            #[inline(always)]
            fn from(variant: DMAM_AW) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Field `dmam` writer - "]
        pub type DMAM_W<'a, const O: u8> = crate::BitWriter<'a, u32, FCR_SPEC, DMAM_AW, O>;
        impl<'a, const O: u8> DMAM_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn mode_0(self) -> &'a mut W {
                self.variant(DMAM_AW::MODE_0)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn mode_1(self) -> &'a mut W {
                self.variant(DMAM_AW::MODE_1)
            }
        }
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum RT_AW {
            #[doc = "0: `0`"]
            ONE_CHARACTER = 0,
            #[doc = "1: `1`"]
            QUARTER_FULL = 1,
            #[doc = "2: `10`"]
            HALF_FULL = 2,
            #[doc = "3: `11`"]
            TWO_LESS_THAN_FULL = 3,
        }
        impl From<RT_AW> for u8 {
            #[inline(always)]
            fn from(variant: RT_AW) -> Self {
                variant as _
            }
        }
        #[doc = "Field `rt` writer - "]
        pub type RT_W<'a, const O: u8> = crate::FieldWriterSafe<'a, u32, FCR_SPEC, u8, RT_AW, 2, O>;
        impl<'a, const O: u8> RT_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn one_character(self) -> &'a mut W {
                self.variant(RT_AW::ONE_CHARACTER)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn quarter_full(self) -> &'a mut W {
                self.variant(RT_AW::QUARTER_FULL)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn half_full(self) -> &'a mut W {
                self.variant(RT_AW::HALF_FULL)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn two_less_than_full(self) -> &'a mut W {
                self.variant(RT_AW::TWO_LESS_THAN_FULL)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            #[must_use]
            pub fn fifoe(&mut self) -> FIFOE_W<0> {
                FIFOE_W::new(self)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            #[must_use]
            pub fn rfifor(&mut self) -> RFIFOR_W<1> {
                RFIFOR_W::new(self)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            #[must_use]
            pub fn xfifor(&mut self) -> XFIFOR_W<2> {
                XFIFOR_W::new(self)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            #[must_use]
            pub fn dmam(&mut self) -> DMAM_W<3> {
                DMAM_W::new(self)
            }
            #[doc = "Bits 6:7"]
            #[inline(always)]
            #[must_use]
            pub fn rt(&mut self) -> RT_W<6> {
                RT_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART FIFO Control Register\n\nThis register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fcr](index.html) module"]
        pub struct FCR_SPEC;
        impl crate::RegisterSpec for FCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [fcr::W](W) writer structure"]
        impl crate::Writable for FCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets fcr to value 0"]
        impl crate::Resettable for FCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "lcr (rw) register accessor: an alias for `Reg<LCR_SPEC>`"]
    pub type LCR = crate::Reg<lcr::LCR_SPEC>;
    #[doc = "UART Line Control Register"]
    pub mod lcr {
        #[doc = "Register `lcr` reader"]
        pub struct R(crate::R<LCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LCR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `lcr` writer"]
        pub struct W(crate::W<LCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LCR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dls` reader - Data Length Select"]
        pub type DLS_R = crate::FieldReader<u8, DLS_A>;
        #[doc = "Data Length Select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum DLS_A {
            #[doc = "0: 5 bits"]
            FIVE = 0,
            #[doc = "1: 6 bits"]
            SIX = 1,
            #[doc = "2: 7 bits"]
            SEVEN = 2,
            #[doc = "3: 8 bits"]
            EIGHT = 3,
        }
        impl From<DLS_A> for u8 {
            #[inline(always)]
            fn from(variant: DLS_A) -> Self {
                variant as _
            }
        }
        impl DLS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DLS_A {
                match self.bits {
                    0 => DLS_A::FIVE,
                    1 => DLS_A::SIX,
                    2 => DLS_A::SEVEN,
                    3 => DLS_A::EIGHT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FIVE`"]
            #[inline(always)]
            pub fn is_five(&self) -> bool {
                *self == DLS_A::FIVE
            }
            #[doc = "Checks if the value of the field is `SIX`"]
            #[inline(always)]
            pub fn is_six(&self) -> bool {
                *self == DLS_A::SIX
            }
            #[doc = "Checks if the value of the field is `SEVEN`"]
            #[inline(always)]
            pub fn is_seven(&self) -> bool {
                *self == DLS_A::SEVEN
            }
            #[doc = "Checks if the value of the field is `EIGHT`"]
            #[inline(always)]
            pub fn is_eight(&self) -> bool {
                *self == DLS_A::EIGHT
            }
        }
        #[doc = "Field `dls` writer - Data Length Select"]
        pub type DLS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, LCR_SPEC, u8, DLS_A, 2, O>;
        impl<'a, const O: u8> DLS_W<'a, O> {
            #[doc = "5 bits"]
            #[inline(always)]
            pub fn five(self) -> &'a mut W {
                self.variant(DLS_A::FIVE)
            }
            #[doc = "6 bits"]
            #[inline(always)]
            pub fn six(self) -> &'a mut W {
                self.variant(DLS_A::SIX)
            }
            #[doc = "7 bits"]
            #[inline(always)]
            pub fn seven(self) -> &'a mut W {
                self.variant(DLS_A::SEVEN)
            }
            #[doc = "8 bits"]
            #[inline(always)]
            pub fn eight(self) -> &'a mut W {
                self.variant(DLS_A::EIGHT)
            }
        }
        #[doc = "Field `stop` reader - Number of stop bits"]
        pub type STOP_R = crate::BitReader<STOP_A>;
        #[doc = "Number of stop bits\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum STOP_A {
            #[doc = "0: 1 stop bit"]
            ONE = 0,
            #[doc = "1: 1.5 stop bits when DLS(LCR\\[1:0\\]) is zero, else 2 stop bits"]
            TWO = 1,
        }
        impl From<STOP_A> for bool {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl STOP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    false => STOP_A::ONE,
                    true => STOP_A::TWO,
                }
            }
            #[doc = "Checks if the value of the field is `ONE`"]
            #[inline(always)]
            pub fn is_one(&self) -> bool {
                *self == STOP_A::ONE
            }
            #[doc = "Checks if the value of the field is `TWO`"]
            #[inline(always)]
            pub fn is_two(&self) -> bool {
                *self == STOP_A::TWO
            }
        }
        #[doc = "Field `stop` writer - Number of stop bits"]
        pub type STOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCR_SPEC, STOP_A, O>;
        impl<'a, const O: u8> STOP_W<'a, O> {
            #[doc = "1 stop bit"]
            #[inline(always)]
            pub fn one(self) -> &'a mut W {
                self.variant(STOP_A::ONE)
            }
            #[doc = "1.5 stop bits when DLS(LCR\\[1:0\\]) is zero, else 2 stop bits"]
            #[inline(always)]
            pub fn two(self) -> &'a mut W {
                self.variant(STOP_A::TWO)
            }
        }
        #[doc = "Field `pen` reader - Parity Enable"]
        pub type PEN_R = crate::BitReader<PEN_A>;
        #[doc = "Parity Enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PEN_A {
            #[doc = "0: `0`"]
            DISABLED = 0,
            #[doc = "1: `1`"]
            ENABLED = 1,
        }
        impl From<PEN_A> for bool {
            #[inline(always)]
            fn from(variant: PEN_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PEN_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PEN_A {
                match self.bits {
                    false => PEN_A::DISABLED,
                    true => PEN_A::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PEN_A::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PEN_A::ENABLED
            }
        }
        #[doc = "Field `pen` writer - Parity Enable"]
        pub type PEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCR_SPEC, PEN_A, O>;
        impl<'a, const O: u8> PEN_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEN_A::DISABLED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEN_A::ENABLED)
            }
        }
        #[doc = "Field `eps` reader - Even Parity Select"]
        pub type EPS_R = crate::FieldReader<u8, EPS_A>;
        #[doc = "Even Parity Select\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum EPS_A {
            #[doc = "0: `0`"]
            ODD = 0,
            #[doc = "1: `1`"]
            EVEN = 1,
            #[doc = "2: `10`"]
            RS485_DATA = 2,
            #[doc = "3: `11`"]
            RS485_ADDR = 3,
        }
        impl From<EPS_A> for u8 {
            #[inline(always)]
            fn from(variant: EPS_A) -> Self {
                variant as _
            }
        }
        impl EPS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EPS_A {
                match self.bits {
                    0 => EPS_A::ODD,
                    1 => EPS_A::EVEN,
                    2 => EPS_A::RS485_DATA,
                    3 => EPS_A::RS485_ADDR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ODD`"]
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                *self == EPS_A::ODD
            }
            #[doc = "Checks if the value of the field is `EVEN`"]
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                *self == EPS_A::EVEN
            }
            #[doc = "Checks if the value of the field is `RS485_DATA`"]
            #[inline(always)]
            pub fn is_rs485_data(&self) -> bool {
                *self == EPS_A::RS485_DATA
            }
            #[doc = "Checks if the value of the field is `RS485_ADDR`"]
            #[inline(always)]
            pub fn is_rs485_addr(&self) -> bool {
                *self == EPS_A::RS485_ADDR
            }
        }
        #[doc = "Field `eps` writer - Even Parity Select"]
        pub type EPS_W<'a, const O: u8> =
            crate::FieldWriterSafe<'a, u32, LCR_SPEC, u8, EPS_A, 2, O>;
        impl<'a, const O: u8> EPS_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(EPS_A::ODD)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(EPS_A::EVEN)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn rs485_data(self) -> &'a mut W {
                self.variant(EPS_A::RS485_DATA)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn rs485_addr(self) -> &'a mut W {
                self.variant(EPS_A::RS485_ADDR)
            }
        }
        #[doc = "Field `bc` reader - Break Control Bit"]
        pub type BC_R = crate::BitReader<bool>;
        #[doc = "Field `bc` writer - Break Control Bit"]
        pub type BC_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCR_SPEC, bool, O>;
        #[doc = "Field `dlab` reader - Divisor Latch Access Bit"]
        pub type DLAB_R = crate::BitReader<DLAB_A>;
        #[doc = "Divisor Latch Access Bit\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DLAB_A {
            #[doc = "0: `0`"]
            RX_BUFFER = 0,
            #[doc = "1: `1`"]
            DIVISOR_LATCH = 1,
        }
        impl From<DLAB_A> for bool {
            #[inline(always)]
            fn from(variant: DLAB_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DLAB_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DLAB_A {
                match self.bits {
                    false => DLAB_A::RX_BUFFER,
                    true => DLAB_A::DIVISOR_LATCH,
                }
            }
            #[doc = "Checks if the value of the field is `RX_BUFFER`"]
            #[inline(always)]
            pub fn is_rx_buffer(&self) -> bool {
                *self == DLAB_A::RX_BUFFER
            }
            #[doc = "Checks if the value of the field is `DIVISOR_LATCH`"]
            #[inline(always)]
            pub fn is_divisor_latch(&self) -> bool {
                *self == DLAB_A::DIVISOR_LATCH
            }
        }
        #[doc = "Field `dlab` writer - Divisor Latch Access Bit"]
        pub type DLAB_W<'a, const O: u8> = crate::BitWriter<'a, u32, LCR_SPEC, DLAB_A, O>;
        impl<'a, const O: u8> DLAB_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn rx_buffer(self) -> &'a mut W {
                self.variant(DLAB_A::RX_BUFFER)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn divisor_latch(self) -> &'a mut W {
                self.variant(DLAB_A::DIVISOR_LATCH)
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Data Length Select"]
            #[inline(always)]
            pub fn dls(&self) -> DLS_R {
                DLS_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Number of stop bits"]
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline(always)]
            pub fn pen(&self) -> PEN_R {
                PEN_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - Even Parity Select"]
            #[inline(always)]
            pub fn eps(&self) -> EPS_R {
                EPS_R::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bit 6 - Break Control Bit"]
            #[inline(always)]
            pub fn bc(&self) -> BC_R {
                BC_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Divisor Latch Access Bit"]
            #[inline(always)]
            pub fn dlab(&self) -> DLAB_R {
                DLAB_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Data Length Select"]
            #[inline(always)]
            #[must_use]
            pub fn dls(&mut self) -> DLS_W<0> {
                DLS_W::new(self)
            }
            #[doc = "Bit 2 - Number of stop bits"]
            #[inline(always)]
            #[must_use]
            pub fn stop(&mut self) -> STOP_W<2> {
                STOP_W::new(self)
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline(always)]
            #[must_use]
            pub fn pen(&mut self) -> PEN_W<3> {
                PEN_W::new(self)
            }
            #[doc = "Bits 4:5 - Even Parity Select"]
            #[inline(always)]
            #[must_use]
            pub fn eps(&mut self) -> EPS_W<4> {
                EPS_W::new(self)
            }
            #[doc = "Bit 6 - Break Control Bit"]
            #[inline(always)]
            #[must_use]
            pub fn bc(&mut self) -> BC_W<6> {
                BC_W::new(self)
            }
            #[doc = "Bit 7 - Divisor Latch Access Bit"]
            #[inline(always)]
            #[must_use]
            pub fn dlab(&mut self) -> DLAB_W<7> {
                DLAB_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Line Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcr](index.html) module"]
        pub struct LCR_SPEC;
        impl crate::RegisterSpec for LCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [lcr::R](R) reader structure"]
        impl crate::Readable for LCR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [lcr::W](W) writer structure"]
        impl crate::Writable for LCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets lcr to value 0"]
        impl crate::Resettable for LCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "mcr (rw) register accessor: an alias for `Reg<MCR_SPEC>`"]
    pub type MCR = crate::Reg<mcr::MCR_SPEC>;
    #[doc = "UART Modem Control Register"]
    pub mod mcr {
        #[doc = "Register `mcr` reader"]
        pub struct R(crate::R<MCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MCR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MCR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `mcr` writer"]
        pub struct W(crate::W<MCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MCR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MCR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dtr` reader - Data Terminal Ready"]
        pub type DTR_R = crate::BitReader<DTR_A>;
        #[doc = "Data Terminal Ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DTR_A {
            #[doc = "0: `0`"]
            DEASSERTED = 0,
            #[doc = "1: `1`"]
            ASSERTED = 1,
        }
        impl From<DTR_A> for bool {
            #[inline(always)]
            fn from(variant: DTR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DTR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DTR_A {
                match self.bits {
                    false => DTR_A::DEASSERTED,
                    true => DTR_A::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline(always)]
            pub fn is_deasserted(&self) -> bool {
                *self == DTR_A::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline(always)]
            pub fn is_asserted(&self) -> bool {
                *self == DTR_A::ASSERTED
            }
        }
        #[doc = "Field `dtr` writer - Data Terminal Ready"]
        pub type DTR_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR_SPEC, DTR_A, O>;
        impl<'a, const O: u8> DTR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(DTR_A::DEASSERTED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn asserted(self) -> &'a mut W {
                self.variant(DTR_A::ASSERTED)
            }
        }
        #[doc = "Field `rts` reader - Request to Send"]
        pub type RTS_R = crate::BitReader<RTS_A>;
        #[doc = "Request to Send\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RTS_A {
            #[doc = "0: `0`"]
            DEASSERTED = 0,
            #[doc = "1: `1`"]
            ASSERTED = 1,
        }
        impl From<RTS_A> for bool {
            #[inline(always)]
            fn from(variant: RTS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RTS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RTS_A {
                match self.bits {
                    false => RTS_A::DEASSERTED,
                    true => RTS_A::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline(always)]
            pub fn is_deasserted(&self) -> bool {
                *self == RTS_A::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline(always)]
            pub fn is_asserted(&self) -> bool {
                *self == RTS_A::ASSERTED
            }
        }
        #[doc = "Field `rts` writer - Request to Send"]
        pub type RTS_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR_SPEC, RTS_A, O>;
        impl<'a, const O: u8> RTS_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(RTS_A::DEASSERTED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn asserted(self) -> &'a mut W {
                self.variant(RTS_A::ASSERTED)
            }
        }
        #[doc = "Field `loop` reader - Loop Back Mode"]
        pub type LOOP_R = crate::BitReader<LOOP_A>;
        #[doc = "Loop Back Mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum LOOP_A {
            #[doc = "0: `0`"]
            NORMAL = 0,
            #[doc = "1: `1`"]
            LOOP_BACK = 1,
        }
        impl From<LOOP_A> for bool {
            #[inline(always)]
            fn from(variant: LOOP_A) -> Self {
                variant as u8 != 0
            }
        }
        impl LOOP_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LOOP_A {
                match self.bits {
                    false => LOOP_A::NORMAL,
                    true => LOOP_A::LOOP_BACK,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                *self == LOOP_A::NORMAL
            }
            #[doc = "Checks if the value of the field is `LOOP_BACK`"]
            #[inline(always)]
            pub fn is_loop_back(&self) -> bool {
                *self == LOOP_A::LOOP_BACK
            }
        }
        #[doc = "Field `loop` writer - Loop Back Mode"]
        pub type LOOP_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR_SPEC, LOOP_A, O>;
        impl<'a, const O: u8> LOOP_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(LOOP_A::NORMAL)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn loop_back(self) -> &'a mut W {
                self.variant(LOOP_A::LOOP_BACK)
            }
        }
        impl R {
            #[doc = "Bit 0 - Data Terminal Ready"]
            #[inline(always)]
            pub fn dtr(&self) -> DTR_R {
                DTR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Request to Send"]
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 4 - Loop Back Mode"]
            #[inline(always)]
            pub fn loop_(&self) -> LOOP_R {
                LOOP_R::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data Terminal Ready"]
            #[inline(always)]
            #[must_use]
            pub fn dtr(&mut self) -> DTR_W<0> {
                DTR_W::new(self)
            }
            #[doc = "Bit 1 - Request to Send"]
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<1> {
                RTS_W::new(self)
            }
            #[doc = "Bit 4 - Loop Back Mode"]
            #[inline(always)]
            #[must_use]
            pub fn loop_(&mut self) -> LOOP_W<4> {
                LOOP_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Modem Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcr](index.html) module"]
        pub struct MCR_SPEC;
        impl crate::RegisterSpec for MCR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [mcr::R](R) reader structure"]
        impl crate::Readable for MCR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [mcr::W](W) writer structure"]
        impl crate::Writable for MCR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets mcr to value 0"]
        impl crate::Resettable for MCR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "lsr (rw) register accessor: an alias for `Reg<LSR_SPEC>`"]
    pub type LSR = crate::Reg<lsr::LSR_SPEC>;
    #[doc = "UART Line Status Register"]
    pub mod lsr {
        #[doc = "Register `lsr` reader"]
        pub struct R(crate::R<LSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<LSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<LSR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `lsr` writer"]
        pub struct W(crate::W<LSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<LSR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<LSR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dr` reader - Data Ready"]
        pub type DR_R = crate::BitReader<DR_A>;
        #[doc = "Data Ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DR_A {
            #[doc = "1: `1`"]
            READY = 1,
        }
        impl From<DR_A> for bool {
            #[inline(always)]
            fn from(variant: DR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<DR_A> {
                match self.bits {
                    true => Some(DR_A::READY),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                *self == DR_A::READY
            }
        }
        #[doc = "Field `dr` writer - Data Ready"]
        pub type DR_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, DR_A, O>;
        impl<'a, const O: u8> DR_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ready(self) -> &'a mut W {
                self.variant(DR_A::READY)
            }
        }
        #[doc = "Field `oe` reader - Overrun Error"]
        pub type OE_R = crate::BitReader<OE_A>;
        #[doc = "Overrun Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum OE_A {
            #[doc = "1: `1`"]
            ERROR = 1,
        }
        impl From<OE_A> for bool {
            #[inline(always)]
            fn from(variant: OE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl OE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<OE_A> {
                match self.bits {
                    true => Some(OE_A::ERROR),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == OE_A::ERROR
            }
        }
        #[doc = "Field `oe` writer - Overrun Error"]
        pub type OE_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, OE_A, O>;
        impl<'a, const O: u8> OE_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(OE_A::ERROR)
            }
        }
        #[doc = "Field `pe` reader - Parity Error"]
        pub type PE_R = crate::BitReader<PE_A>;
        #[doc = "Parity Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum PE_A {
            #[doc = "1: `1`"]
            ERROR = 1,
        }
        impl From<PE_A> for bool {
            #[inline(always)]
            fn from(variant: PE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl PE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<PE_A> {
                match self.bits {
                    true => Some(PE_A::ERROR),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == PE_A::ERROR
            }
        }
        #[doc = "Field `pe` writer - Parity Error"]
        pub type PE_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, PE_A, O>;
        impl<'a, const O: u8> PE_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(PE_A::ERROR)
            }
        }
        #[doc = "Field `fe` reader - Framing Error"]
        pub type FE_R = crate::BitReader<FE_A>;
        #[doc = "Framing Error\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FE_A {
            #[doc = "1: `1`"]
            ERROR = 1,
        }
        impl From<FE_A> for bool {
            #[inline(always)]
            fn from(variant: FE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<FE_A> {
                match self.bits {
                    true => Some(FE_A::ERROR),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == FE_A::ERROR
            }
        }
        #[doc = "Field `fe` writer - Framing Error"]
        pub type FE_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, FE_A, O>;
        impl<'a, const O: u8> FE_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(FE_A::ERROR)
            }
        }
        #[doc = "Field `bi` reader - Break Interrupt"]
        pub type BI_R = crate::BitReader<bool>;
        #[doc = "Field `bi` writer - Break Interrupt"]
        pub type BI_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, bool, O>;
        #[doc = "Field `thre` reader - TX Holding Register Empty"]
        pub type THRE_R = crate::BitReader<THRE_A>;
        #[doc = "TX Holding Register Empty\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum THRE_A {
            #[doc = "1: `1`"]
            EMPTY = 1,
        }
        impl From<THRE_A> for bool {
            #[inline(always)]
            fn from(variant: THRE_A) -> Self {
                variant as u8 != 0
            }
        }
        impl THRE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<THRE_A> {
                match self.bits {
                    true => Some(THRE_A::EMPTY),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == THRE_A::EMPTY
            }
        }
        #[doc = "Field `thre` writer - TX Holding Register Empty"]
        pub type THRE_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, THRE_A, O>;
        impl<'a, const O: u8> THRE_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn empty(self) -> &'a mut W {
                self.variant(THRE_A::EMPTY)
            }
        }
        #[doc = "Field `temt` reader - Transmitter Empty"]
        pub type TEMT_R = crate::BitReader<TEMT_A>;
        #[doc = "Transmitter Empty\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TEMT_A {
            #[doc = "1: `1`"]
            EMPTY = 1,
        }
        impl From<TEMT_A> for bool {
            #[inline(always)]
            fn from(variant: TEMT_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TEMT_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<TEMT_A> {
                match self.bits {
                    true => Some(TEMT_A::EMPTY),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                *self == TEMT_A::EMPTY
            }
        }
        #[doc = "Field `temt` writer - Transmitter Empty"]
        pub type TEMT_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, TEMT_A, O>;
        impl<'a, const O: u8> TEMT_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn empty(self) -> &'a mut W {
                self.variant(TEMT_A::EMPTY)
            }
        }
        #[doc = "Field `fifoerr` reader - RX Data Error in FIFO"]
        pub type FIFOERR_R = crate::BitReader<FIFOERR_A>;
        #[doc = "RX Data Error in FIFO\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum FIFOERR_A {
            #[doc = "1: `1`"]
            ERROR = 1,
        }
        impl From<FIFOERR_A> for bool {
            #[inline(always)]
            fn from(variant: FIFOERR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl FIFOERR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> Option<FIFOERR_A> {
                match self.bits {
                    true => Some(FIFOERR_A::ERROR),
                    _ => None,
                }
            }
            #[doc = "Checks if the value of the field is `ERROR`"]
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                *self == FIFOERR_A::ERROR
            }
        }
        #[doc = "Field `fifoerr` writer - RX Data Error in FIFO"]
        pub type FIFOERR_W<'a, const O: u8> = crate::BitWriter<'a, u32, LSR_SPEC, FIFOERR_A, O>;
        impl<'a, const O: u8> FIFOERR_W<'a, O> {
            #[doc = "`1`"]
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(FIFOERR_A::ERROR)
            }
        }
        impl R {
            #[doc = "Bit 0 - Data Ready"]
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Overrun Error"]
            #[inline(always)]
            pub fn oe(&self) -> OE_R {
                OE_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Parity Error"]
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Framing Error"]
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Break Interrupt"]
            #[inline(always)]
            pub fn bi(&self) -> BI_R {
                BI_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - TX Holding Register Empty"]
            #[inline(always)]
            pub fn thre(&self) -> THRE_R {
                THRE_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Transmitter Empty"]
            #[inline(always)]
            pub fn temt(&self) -> TEMT_R {
                TEMT_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RX Data Error in FIFO"]
            #[inline(always)]
            pub fn fifoerr(&self) -> FIFOERR_R {
                FIFOERR_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data Ready"]
            #[inline(always)]
            #[must_use]
            pub fn dr(&mut self) -> DR_W<0> {
                DR_W::new(self)
            }
            #[doc = "Bit 1 - Overrun Error"]
            #[inline(always)]
            #[must_use]
            pub fn oe(&mut self) -> OE_W<1> {
                OE_W::new(self)
            }
            #[doc = "Bit 2 - Parity Error"]
            #[inline(always)]
            #[must_use]
            pub fn pe(&mut self) -> PE_W<2> {
                PE_W::new(self)
            }
            #[doc = "Bit 3 - Framing Error"]
            #[inline(always)]
            #[must_use]
            pub fn fe(&mut self) -> FE_W<3> {
                FE_W::new(self)
            }
            #[doc = "Bit 4 - Break Interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn bi(&mut self) -> BI_W<4> {
                BI_W::new(self)
            }
            #[doc = "Bit 5 - TX Holding Register Empty"]
            #[inline(always)]
            #[must_use]
            pub fn thre(&mut self) -> THRE_W<5> {
                THRE_W::new(self)
            }
            #[doc = "Bit 6 - Transmitter Empty"]
            #[inline(always)]
            #[must_use]
            pub fn temt(&mut self) -> TEMT_W<6> {
                TEMT_W::new(self)
            }
            #[doc = "Bit 7 - RX Data Error in FIFO"]
            #[inline(always)]
            #[must_use]
            pub fn fifoerr(&mut self) -> FIFOERR_W<7> {
                FIFOERR_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Line Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lsr](index.html) module"]
        pub struct LSR_SPEC;
        impl crate::RegisterSpec for LSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [lsr::R](R) reader structure"]
        impl crate::Readable for LSR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [lsr::W](W) writer structure"]
        impl crate::Writable for LSR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets lsr to value 0"]
        impl crate::Resettable for LSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "msr (rw) register accessor: an alias for `Reg<MSR_SPEC>`"]
    pub type MSR = crate::Reg<msr::MSR_SPEC>;
    #[doc = "UART Modem Status Register"]
    pub mod msr {
        #[doc = "Register `msr` reader"]
        pub struct R(crate::R<MSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<MSR_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<MSR_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `msr` writer"]
        pub struct W(crate::W<MSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<MSR_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<MSR_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `dcts` reader - Delta Clear to Send"]
        pub type DCTS_R = crate::BitReader<DCTS_A>;
        #[doc = "Delta Clear to Send\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DCTS_A {
            #[doc = "0: `0`"]
            NO_CHANGE = 0,
            #[doc = "1: `1`"]
            CHANGE = 1,
        }
        impl From<DCTS_A> for bool {
            #[inline(always)]
            fn from(variant: DCTS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DCTS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DCTS_A {
                match self.bits {
                    false => DCTS_A::NO_CHANGE,
                    true => DCTS_A::CHANGE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == DCTS_A::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `CHANGE`"]
            #[inline(always)]
            pub fn is_change(&self) -> bool {
                *self == DCTS_A::CHANGE
            }
        }
        #[doc = "Field `dcts` writer - Delta Clear to Send"]
        pub type DCTS_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, DCTS_A, O>;
        impl<'a, const O: u8> DCTS_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(DCTS_A::NO_CHANGE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn change(self) -> &'a mut W {
                self.variant(DCTS_A::CHANGE)
            }
        }
        #[doc = "Field `ddsr` reader - Delta Data Set Ready"]
        pub type DDSR_R = crate::BitReader<DDSR_A>;
        #[doc = "Delta Data Set Ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DDSR_A {
            #[doc = "0: `0`"]
            NO_CHANGE = 0,
            #[doc = "1: `1`"]
            CHANGE = 1,
        }
        impl From<DDSR_A> for bool {
            #[inline(always)]
            fn from(variant: DDSR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DDSR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DDSR_A {
                match self.bits {
                    false => DDSR_A::NO_CHANGE,
                    true => DDSR_A::CHANGE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == DDSR_A::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `CHANGE`"]
            #[inline(always)]
            pub fn is_change(&self) -> bool {
                *self == DDSR_A::CHANGE
            }
        }
        #[doc = "Field `ddsr` writer - Delta Data Set Ready"]
        pub type DDSR_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, DDSR_A, O>;
        impl<'a, const O: u8> DDSR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(DDSR_A::NO_CHANGE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn change(self) -> &'a mut W {
                self.variant(DDSR_A::CHANGE)
            }
        }
        #[doc = "Field `teri` reader - Trailing Edge Ring Indicator"]
        pub type TERI_R = crate::BitReader<TERI_A>;
        #[doc = "Trailing Edge Ring Indicator\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum TERI_A {
            #[doc = "0: `0`"]
            NO_CHANGE = 0,
            #[doc = "1: `1`"]
            CHANGE = 1,
        }
        impl From<TERI_A> for bool {
            #[inline(always)]
            fn from(variant: TERI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl TERI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TERI_A {
                match self.bits {
                    false => TERI_A::NO_CHANGE,
                    true => TERI_A::CHANGE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == TERI_A::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `CHANGE`"]
            #[inline(always)]
            pub fn is_change(&self) -> bool {
                *self == TERI_A::CHANGE
            }
        }
        #[doc = "Field `teri` writer - Trailing Edge Ring Indicator"]
        pub type TERI_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, TERI_A, O>;
        impl<'a, const O: u8> TERI_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(TERI_A::NO_CHANGE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn change(self) -> &'a mut W {
                self.variant(TERI_A::CHANGE)
            }
        }
        #[doc = "Field `ddcd` reader - Delta Data Carrier Detect"]
        pub type DDCD_R = crate::BitReader<DDCD_A>;
        #[doc = "Delta Data Carrier Detect\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DDCD_A {
            #[doc = "0: `0`"]
            NO_CHANGE = 0,
            #[doc = "1: `1`"]
            CHANGE = 1,
        }
        impl From<DDCD_A> for bool {
            #[inline(always)]
            fn from(variant: DDCD_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DDCD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DDCD_A {
                match self.bits {
                    false => DDCD_A::NO_CHANGE,
                    true => DDCD_A::CHANGE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == DDCD_A::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `CHANGE`"]
            #[inline(always)]
            pub fn is_change(&self) -> bool {
                *self == DDCD_A::CHANGE
            }
        }
        #[doc = "Field `ddcd` writer - Delta Data Carrier Detect"]
        pub type DDCD_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, DDCD_A, O>;
        impl<'a, const O: u8> DDCD_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(DDCD_A::NO_CHANGE)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn change(self) -> &'a mut W {
                self.variant(DDCD_A::CHANGE)
            }
        }
        #[doc = "Field `cts` reader - Line State of Clear To Send"]
        pub type CTS_R = crate::BitReader<CTS_A>;
        #[doc = "Line State of Clear To Send\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum CTS_A {
            #[doc = "0: `0`"]
            DEASSERTED = 0,
            #[doc = "1: `1`"]
            ASSERTED = 1,
        }
        impl From<CTS_A> for bool {
            #[inline(always)]
            fn from(variant: CTS_A) -> Self {
                variant as u8 != 0
            }
        }
        impl CTS_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> CTS_A {
                match self.bits {
                    false => CTS_A::DEASSERTED,
                    true => CTS_A::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline(always)]
            pub fn is_deasserted(&self) -> bool {
                *self == CTS_A::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline(always)]
            pub fn is_asserted(&self) -> bool {
                *self == CTS_A::ASSERTED
            }
        }
        #[doc = "Field `cts` writer - Line State of Clear To Send"]
        pub type CTS_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, CTS_A, O>;
        impl<'a, const O: u8> CTS_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(CTS_A::DEASSERTED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn asserted(self) -> &'a mut W {
                self.variant(CTS_A::ASSERTED)
            }
        }
        #[doc = "Field `dsr` reader - Line State of Data Set Ready"]
        pub type DSR_R = crate::BitReader<DSR_A>;
        #[doc = "Line State of Data Set Ready\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DSR_A {
            #[doc = "0: `0`"]
            DEASSERTED = 0,
            #[doc = "1: `1`"]
            ASSERTED = 1,
        }
        impl From<DSR_A> for bool {
            #[inline(always)]
            fn from(variant: DSR_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DSR_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DSR_A {
                match self.bits {
                    false => DSR_A::DEASSERTED,
                    true => DSR_A::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline(always)]
            pub fn is_deasserted(&self) -> bool {
                *self == DSR_A::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline(always)]
            pub fn is_asserted(&self) -> bool {
                *self == DSR_A::ASSERTED
            }
        }
        #[doc = "Field `dsr` writer - Line State of Data Set Ready"]
        pub type DSR_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, DSR_A, O>;
        impl<'a, const O: u8> DSR_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(DSR_A::DEASSERTED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn asserted(self) -> &'a mut W {
                self.variant(DSR_A::ASSERTED)
            }
        }
        #[doc = "Field `ri` reader - Line State of Ring Indicator"]
        pub type RI_R = crate::BitReader<RI_A>;
        #[doc = "Line State of Ring Indicator\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum RI_A {
            #[doc = "0: `0`"]
            DEASSERTED = 0,
            #[doc = "1: `1`"]
            ASSERTED = 1,
        }
        impl From<RI_A> for bool {
            #[inline(always)]
            fn from(variant: RI_A) -> Self {
                variant as u8 != 0
            }
        }
        impl RI_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RI_A {
                match self.bits {
                    false => RI_A::DEASSERTED,
                    true => RI_A::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline(always)]
            pub fn is_deasserted(&self) -> bool {
                *self == RI_A::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline(always)]
            pub fn is_asserted(&self) -> bool {
                *self == RI_A::ASSERTED
            }
        }
        #[doc = "Field `ri` writer - Line State of Ring Indicator"]
        pub type RI_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, RI_A, O>;
        impl<'a, const O: u8> RI_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(RI_A::DEASSERTED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn asserted(self) -> &'a mut W {
                self.variant(RI_A::ASSERTED)
            }
        }
        #[doc = "Field `dcd` reader - Line State of Data Carrier Detect"]
        pub type DCD_R = crate::BitReader<DCD_A>;
        #[doc = "Line State of Data Carrier Detect\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        pub enum DCD_A {
            #[doc = "0: `0`"]
            DEASSERTED = 0,
            #[doc = "1: `1`"]
            ASSERTED = 1,
        }
        impl From<DCD_A> for bool {
            #[inline(always)]
            fn from(variant: DCD_A) -> Self {
                variant as u8 != 0
            }
        }
        impl DCD_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DCD_A {
                match self.bits {
                    false => DCD_A::DEASSERTED,
                    true => DCD_A::ASSERTED,
                }
            }
            #[doc = "Checks if the value of the field is `DEASSERTED`"]
            #[inline(always)]
            pub fn is_deasserted(&self) -> bool {
                *self == DCD_A::DEASSERTED
            }
            #[doc = "Checks if the value of the field is `ASSERTED`"]
            #[inline(always)]
            pub fn is_asserted(&self) -> bool {
                *self == DCD_A::ASSERTED
            }
        }
        #[doc = "Field `dcd` writer - Line State of Data Carrier Detect"]
        pub type DCD_W<'a, const O: u8> = crate::BitWriter<'a, u32, MSR_SPEC, DCD_A, O>;
        impl<'a, const O: u8> DCD_W<'a, O> {
            #[doc = "`0`"]
            #[inline(always)]
            pub fn deasserted(self) -> &'a mut W {
                self.variant(DCD_A::DEASSERTED)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn asserted(self) -> &'a mut W {
                self.variant(DCD_A::ASSERTED)
            }
        }
        impl R {
            #[doc = "Bit 0 - Delta Clear to Send"]
            #[inline(always)]
            pub fn dcts(&self) -> DCTS_R {
                DCTS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Delta Data Set Ready"]
            #[inline(always)]
            pub fn ddsr(&self) -> DDSR_R {
                DDSR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Trailing Edge Ring Indicator"]
            #[inline(always)]
            pub fn teri(&self) -> TERI_R {
                TERI_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Delta Data Carrier Detect"]
            #[inline(always)]
            pub fn ddcd(&self) -> DDCD_R {
                DDCD_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Line State of Clear To Send"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Line State of Data Set Ready"]
            #[inline(always)]
            pub fn dsr(&self) -> DSR_R {
                DSR_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Line State of Ring Indicator"]
            #[inline(always)]
            pub fn ri(&self) -> RI_R {
                RI_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Line State of Data Carrier Detect"]
            #[inline(always)]
            pub fn dcd(&self) -> DCD_R {
                DCD_R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Delta Clear to Send"]
            #[inline(always)]
            #[must_use]
            pub fn dcts(&mut self) -> DCTS_W<0> {
                DCTS_W::new(self)
            }
            #[doc = "Bit 1 - Delta Data Set Ready"]
            #[inline(always)]
            #[must_use]
            pub fn ddsr(&mut self) -> DDSR_W<1> {
                DDSR_W::new(self)
            }
            #[doc = "Bit 2 - Trailing Edge Ring Indicator"]
            #[inline(always)]
            #[must_use]
            pub fn teri(&mut self) -> TERI_W<2> {
                TERI_W::new(self)
            }
            #[doc = "Bit 3 - Delta Data Carrier Detect"]
            #[inline(always)]
            #[must_use]
            pub fn ddcd(&mut self) -> DDCD_W<3> {
                DDCD_W::new(self)
            }
            #[doc = "Bit 4 - Line State of Clear To Send"]
            #[inline(always)]
            #[must_use]
            pub fn cts(&mut self) -> CTS_W<4> {
                CTS_W::new(self)
            }
            #[doc = "Bit 5 - Line State of Data Set Ready"]
            #[inline(always)]
            #[must_use]
            pub fn dsr(&mut self) -> DSR_W<5> {
                DSR_W::new(self)
            }
            #[doc = "Bit 6 - Line State of Ring Indicator"]
            #[inline(always)]
            #[must_use]
            pub fn ri(&mut self) -> RI_W<6> {
                RI_W::new(self)
            }
            #[doc = "Bit 7 - Line State of Data Carrier Detect"]
            #[inline(always)]
            #[must_use]
            pub fn dcd(&mut self) -> DCD_W<7> {
                DCD_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Modem Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msr](index.html) module"]
        pub struct MSR_SPEC;
        impl crate::RegisterSpec for MSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [msr::R](R) reader structure"]
        impl crate::Readable for MSR_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [msr::W](W) writer structure"]
        impl crate::Writable for MSR_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets msr to value 0"]
        impl crate::Resettable for MSR_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
    #[doc = "sch (rw) register accessor: an alias for `Reg<SCH_SPEC>`"]
    pub type SCH = crate::Reg<sch::SCH_SPEC>;
    #[doc = "UART Scratch Register"]
    pub mod sch {
        #[doc = "Register `sch` reader"]
        pub struct R(crate::R<SCH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SCH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl From<crate::R<SCH_SPEC>> for R {
            #[inline(always)]
            fn from(reader: crate::R<SCH_SPEC>) -> Self {
                R(reader)
            }
        }
        #[doc = "Register `sch` writer"]
        pub struct W(crate::W<SCH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SCH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl From<crate::W<SCH_SPEC>> for W {
            #[inline(always)]
            fn from(writer: crate::W<SCH_SPEC>) -> Self {
                W(writer)
            }
        }
        #[doc = "Field `scratch` reader - "]
        pub type SCRATCH_R = crate::FieldReader<u8, u8>;
        #[doc = "Field `scratch` writer - "]
        pub type SCRATCH_W<'a, const O: u8> = crate::FieldWriter<'a, u32, SCH_SPEC, u8, u8, 8, O>;
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn scratch(&self) -> SCRATCH_R {
                SCRATCH_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            #[must_use]
            pub fn scratch(&mut self) -> SCRATCH_W<0> {
                SCRATCH_W::new(self)
            }
            #[doc = "Writes raw bits to the register."]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        #[doc = "UART Scratch Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sch](index.html) module"]
        pub struct SCH_SPEC;
        impl crate::RegisterSpec for SCH_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [sch::R](R) reader structure"]
        impl crate::Readable for SCH_SPEC {
            type Reader = R;
        }
        #[doc = "`write(|w| ..)` method takes [sch::W](W) writer structure"]
        impl crate::Writable for SCH_SPEC {
            type Writer = W;
            const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
        }
        #[doc = "`reset()` method sets sch to value 0"]
        impl crate::Resettable for SCH_SPEC {
            const RESET_VALUE: Self::Ux = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "UART3"]
    pub UART3: UART3,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            UART0: UART0 {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
        }
    }
}
